# I/O模式和事件驱动
# 对于一次I/O操作（以读操作为例），数据会先被拷贝到操作系统内核的缓冲区中，
# 然后从操作系统内核的缓冲区拷贝到应用程序的缓冲区（这种方式称为标准I/O或缓存I/O，大多数文件系统的默认I/O都是这种方式），
# 最后交给进程。所以说，当一个读操作发生时（写操作与之类似），
# 它会经历两个阶段：(1)等待数据准备就绪；(2)将数据从内核拷贝到进程中。

# 由于存在这两个阶段，因此产生了以下几种I/O模式：

# 阻塞 I/O（blocking I/O）：
#     进程发起读操作，如果内核数据尚未就绪，进程会阻塞等待数据直到内核数据就绪并拷贝到进程的内存中。
# 非阻塞 I/O（non-blocking I/O）：
#     进程发起读操作，如果内核数据尚未就绪，进程不阻塞而是收到内核返回的错误信息，进程收到错误信息可以再次发起读操作，一旦内核数据准备就绪，就立即将数据拷贝到了用户内存中，然后返回。
# 多路I/O复用（ I/O multiplexing）：
#     监听多个I/O对象，当I/O对象有变化（数据就绪）的时候就通知用户进程。多路I/O复用的优势并不在于单个I/O操作能处理得更快，而是在于能处理更多的I/O操作。
# 异步 I/O（asynchronous I/O）：
#     进程发起读操作后就可以去做别的事情了，内核收到异步读操作后会立即返回，所以用户进程不阻塞，当内核数据准备就绪时，
#     内核发送一个信号给用户进程，告诉它读操作完成了。

# 通常，我们编写一个处理用户请求的服务器程序时，有以下三种方式可供选择：

# 每收到一个请求，创建一个新的进程，来处理该请求；
# 每收到一个请求，创建一个新的线程，来处理该请求；
# 每收到一个请求，放入一个事件列表，让主进程通过非阻塞I/O方式来处理请求
# 第1种方式实现比较简单，但由于创建进程开销比较大，会导致服务器性能比较差；
# 第2种方式，由于要涉及到线程的同步，有可能会面临竞争、死锁等问题；
# 第3种方式，就是所谓事件驱动的方式，它利用了多路I/O复用和异步I/O的优点，虽然代码逻辑比前面两种都复杂，但能达到最好的性能，这也是目前大多数网络服务器采用的方式。
